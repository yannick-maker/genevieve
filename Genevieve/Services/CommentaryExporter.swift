import Foundation
import AppKit
import PDFKit

/// Exports commentary entries to various formats
struct CommentaryExporter {

    // MARK: - Export Formats

    enum ExportFormat: String, CaseIterable, Identifiable {
        case plainText = "Plain Text (.txt)"
        case markdown = "Markdown (.md)"
        case pdf = "PDF (.pdf)"

        var id: String { rawValue }

        var fileExtension: String {
            switch self {
            case .plainText: return "txt"
            case .markdown: return "md"
            case .pdf: return "pdf"
            }
        }

        var mimeType: String {
            switch self {
            case .plainText: return "text/plain"
            case .markdown: return "text/markdown"
            case .pdf: return "application/pdf"
            }
        }
    }

    // MARK: - Export Options

    struct ExportOptions {
        var includeTimestamps: Bool = true
        var includeMatterInfo: Bool = true
        var includeMetadata: Bool = false
        var groupBySession: Bool = true
        var title: String = "Genevieve Commentary Export"
    }

    // MARK: - Export Methods

    /// Export entries to the specified format
    static func export(
        entries: [CommentaryEntry],
        format: ExportFormat,
        options: ExportOptions = ExportOptions()
    ) -> Data? {
        switch format {
        case .plainText:
            return exportAsPlainText(entries: entries, options: options).data(using: .utf8)
        case .markdown:
            return exportAsMarkdown(entries: entries, options: options).data(using: .utf8)
        case .pdf:
            return exportAsPDF(entries: entries, options: options)
        }
    }

    /// Export and save to file with save dialog
    @MainActor
    static func exportWithSaveDialog(
        entries: [CommentaryEntry],
        format: ExportFormat,
        options: ExportOptions = ExportOptions()
    ) -> Bool {
        guard let data = export(entries: entries, format: format, options: options) else {
            return false
        }

        let savePanel = NSSavePanel()
        savePanel.title = "Export Commentary"
        savePanel.allowedContentTypes = [.init(filenameExtension: format.fileExtension)!]
        savePanel.nameFieldStringValue = "commentary-\(dateString()).\(format.fileExtension)"
        savePanel.canCreateDirectories = true

        guard savePanel.runModal() == .OK, let url = savePanel.url else {
            return false
        }

        do {
            try data.write(to: url)
            return true
        } catch {
            return false
        }
    }

    // MARK: - Plain Text Export

    static func exportAsPlainText(
        entries: [CommentaryEntry],
        options: ExportOptions
    ) -> String {
        var output = ""

        // Header
        output += "═══════════════════════════════════════════════════════════\n"
        output += "  \(options.title)\n"
        output += "  Exported: \(formattedDate(Date()))\n"
        output += "═══════════════════════════════════════════════════════════\n\n"

        // Matter info
        if options.includeMatterInfo, let firstEntry = entries.first, let matter = firstEntry.matter {
            output += "Matter: \(matter.name)\n"
            if let client = matter.clientName {
                output += "Client: \(client)\n"
            }
            output += "\n"
        }

        // Entries
        var currentDate: String?

        for entry in entries.sorted(by: { $0.timestamp < $1.timestamp }) {
            let entryDate = dayString(entry.timestamp)

            // Date header if grouping by session
            if options.groupBySession && entryDate != currentDate {
                currentDate = entryDate
                output += "\n───────────────────────────────────────────────────────────\n"
                output += "  \(entryDate)\n"
                output += "───────────────────────────────────────────────────────────\n\n"
            }

            // Timestamp
            if options.includeTimestamps {
                output += "[\(entry.shortTimestamp)] "
            }

            // Sender
            output += entry.isUserMessage ? "You: " : "Genevieve: "

            // Content
            output += entry.content
            output += "\n\n"
        }

        // Footer
        output += "\n═══════════════════════════════════════════════════════════\n"
        output += "  Generated by Genevieve - AI Legal Drafting Co-Pilot\n"
        output += "═══════════════════════════════════════════════════════════\n"

        return output
    }

    // MARK: - Markdown Export

    static func exportAsMarkdown(
        entries: [CommentaryEntry],
        options: ExportOptions
    ) -> String {
        var output = ""

        // YAML frontmatter
        output += "---\n"
        output += "title: \"\(options.title)\"\n"
        output += "date: \(isoDate(Date()))\n"
        output += "generator: Genevieve\n"

        if let firstEntry = entries.first {
            if let matter = firstEntry.matter {
                output += "matter: \"\(matter.name)\"\n"
                if let client = matter.clientName {
                    output += "client: \"\(client)\"\n"
                }
            }
            if let docType = firstEntry.documentType {
                output += "document_type: \"\(docType)\"\n"
            }
        }

        output += "entries: \(entries.count)\n"
        output += "---\n\n"

        // Title
        output += "# \(options.title)\n\n"

        // Summary
        let userMessages = entries.filter { $0.isUserMessage }.count
        let genevieveMessages = entries.count - userMessages
        output += "> **\(entries.count)** entries | "
        output += "**\(genevieveMessages)** observations | "
        output += "**\(userMessages)** dialogue messages\n\n"

        // Entries grouped by date
        let grouped = Dictionary(grouping: entries) { dayString($0.timestamp) }
        let sortedDates = grouped.keys.sorted()

        for date in sortedDates {
            guard let dayEntries = grouped[date] else { continue }

            output += "## \(date)\n\n"

            for entry in dayEntries.sorted(by: { $0.timestamp < $1.timestamp }) {
                // Timestamp badge
                if options.includeTimestamps {
                    output += "*\(entry.shortTimestamp)*\n\n"
                }

                if entry.isUserMessage {
                    // User message as blockquote
                    output += "> **You:** \(entry.content)\n\n"
                } else {
                    // Genevieve message
                    output += "**Genevieve:**\n\n"
                    output += entry.content
                    output += "\n\n"

                    // Highlight suggestions
                    if entry.hasSuggestion, let suggestion = entry.suggestionText {
                        output += "```suggestion\n"
                        output += suggestion
                        output += "\n```\n\n"
                    }
                }

                output += "---\n\n"
            }
        }

        // Footer
        output += "\n\n*Generated by [Genevieve](https://genevieve.app) - AI Legal Drafting Co-Pilot*\n"

        return output
    }

    // MARK: - PDF Export

    static func exportAsPDF(
        entries: [CommentaryEntry],
        options: ExportOptions
    ) -> Data? {
        // Create attributed string for PDF
        let content = NSMutableAttributedString()

        // Styles
        let titleFont = NSFont.systemFont(ofSize: 24, weight: .bold)
        let headingFont = NSFont.systemFont(ofSize: 16, weight: .semibold)
        let bodyFont = NSFont.systemFont(ofSize: 12, weight: .regular)
        let captionFont = NSFont.systemFont(ofSize: 10, weight: .regular)
        let userFont = NSFont.systemFont(ofSize: 12, weight: .medium)

        let titleStyle = NSMutableParagraphStyle()
        titleStyle.alignment = .center
        titleStyle.paragraphSpacing = 20

        let bodyStyle = NSMutableParagraphStyle()
        bodyStyle.paragraphSpacing = 12
        bodyStyle.lineSpacing = 4

        // Title
        content.append(NSAttributedString(
            string: "\(options.title)\n\n",
            attributes: [
                .font: titleFont,
                .paragraphStyle: titleStyle
            ]
        ))

        // Date
        content.append(NSAttributedString(
            string: "Exported: \(formattedDate(Date()))\n\n",
            attributes: [
                .font: captionFont,
                .foregroundColor: NSColor.secondaryLabelColor,
                .paragraphStyle: titleStyle
            ]
        ))

        // Matter info
        if options.includeMatterInfo, let firstEntry = entries.first, let matter = firstEntry.matter {
            content.append(NSAttributedString(
                string: "Matter: \(matter.name)\n",
                attributes: [.font: bodyFont, .paragraphStyle: bodyStyle]
            ))
            if let client = matter.clientName {
                content.append(NSAttributedString(
                    string: "Client: \(client)\n",
                    attributes: [.font: bodyFont, .paragraphStyle: bodyStyle]
                ))
            }
            content.append(NSAttributedString(string: "\n"))
        }

        // Entries
        var currentDate: String?

        for entry in entries.sorted(by: { $0.timestamp < $1.timestamp }) {
            let entryDate = dayString(entry.timestamp)

            // Date header
            if options.groupBySession && entryDate != currentDate {
                currentDate = entryDate
                content.append(NSAttributedString(
                    string: "\n\(entryDate)\n\n",
                    attributes: [
                        .font: headingFont,
                        .foregroundColor: NSColor.labelColor
                    ]
                ))
            }

            // Timestamp
            if options.includeTimestamps {
                content.append(NSAttributedString(
                    string: "[\(entry.shortTimestamp)] ",
                    attributes: [
                        .font: captionFont,
                        .foregroundColor: NSColor.secondaryLabelColor
                    ]
                ))
            }

            // Sender and content
            if entry.isUserMessage {
                content.append(NSAttributedString(
                    string: "You: ",
                    attributes: [.font: userFont, .foregroundColor: NSColor.systemBlue]
                ))
            } else {
                content.append(NSAttributedString(
                    string: "Genevieve: ",
                    attributes: [.font: userFont, .foregroundColor: NSColor.systemPurple]
                ))
            }

            content.append(NSAttributedString(
                string: entry.content + "\n\n",
                attributes: [.font: bodyFont, .paragraphStyle: bodyStyle]
            ))
        }

        // Footer
        content.append(NSAttributedString(
            string: "\n\nGenerated by Genevieve - AI Legal Drafting Co-Pilot",
            attributes: [
                .font: captionFont,
                .foregroundColor: NSColor.tertiaryLabelColor,
                .paragraphStyle: titleStyle
            ]
        ))

        // Generate PDF
        let pageSize = CGSize(width: 612, height: 792) // US Letter
        let margins = NSEdgeInsets(top: 72, left: 72, bottom: 72, right: 72)
        let textRect = CGRect(
            x: margins.left,
            y: margins.bottom,
            width: pageSize.width - margins.left - margins.right,
            height: pageSize.height - margins.top - margins.bottom
        )

        let pdfData = NSMutableData()

        guard let consumer = CGDataConsumer(data: pdfData as CFMutableData),
              let context = CGContext(consumer: consumer, mediaBox: nil, nil) else {
            return nil
        }

        let framesetter = CTFramesetterCreateWithAttributedString(content)
        var currentRange = CFRange(location: 0, length: 0)
        var pageIndex = 0

        while currentRange.location < content.length {
            var pageRect = CGRect(origin: .zero, size: pageSize)
            context.beginPage(mediaBox: &pageRect)

            // Flip coordinate system
            context.translateBy(x: 0, y: pageSize.height)
            context.scaleBy(x: 1, y: -1)

            let path = CGPath(rect: textRect, transform: nil)
            let frame = CTFramesetterCreateFrame(
                framesetter,
                currentRange,
                path,
                nil
            )

            CTFrameDraw(frame, context)

            let frameRange = CTFrameGetVisibleStringRange(frame)
            currentRange.location += frameRange.length

            // Page number
            let pageNum = "\(pageIndex + 1)"
            let pageNumAttr = NSAttributedString(
                string: pageNum,
                attributes: [
                    .font: NSFont.systemFont(ofSize: 10),
                    .foregroundColor: NSColor.secondaryLabelColor
                ]
            )
            let pageNumLine = CTLineCreateWithAttributedString(pageNumAttr)
            let pageNumWidth = CTLineGetTypographicBounds(pageNumLine, nil, nil, nil)
            context.textPosition = CGPoint(
                x: (pageSize.width - pageNumWidth) / 2,
                y: pageSize.height - 36
            )
            CTLineDraw(pageNumLine, context)

            context.endPage()
            pageIndex += 1
        }

        context.closePDF()

        return pdfData as Data
    }

    // MARK: - Helpers

    private static func dateString() -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd"
        return formatter.string(from: Date())
    }

    private static func formattedDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .long
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }

    private static func dayString(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "EEEE, MMMM d, yyyy"
        return formatter.string(from: date)
    }

    private static func isoDate(_ date: Date) -> String {
        let formatter = ISO8601DateFormatter()
        return formatter.string(from: date)
    }
}
